<html>
  <head>
    <title>Getting Started</title>
  </head>
  <body>
    <h1>Getting Started</h1>
    
    <p>This guide assumes you are familiar with unit-testing and 
    <a href="http://junit.org/">JUnit</a>.</p>
    
    <p>For a simple example we are going to test a publish/subscribe message 
    system. A Publisher sends objects to zero or more Subscribers.  We want 
    to test the Publisher, which involves testing its interactions with its 
    Subscribers.</p>
   
    <p>The Subscriber interface looks like this:</p>
   
    <div class="Source Java">
<pre>interface Subscriber {
    void receive(Object message);
}</pre>
    </div>
  
    <p>We will test that a Publisher sends a message to a single registered 
    Subscriber. To test interactions between the Publisher and the Subscriber
    we will use a mock Subscriber object.</p>
    
    <p>First we must import the jMock classes, define our test fixture class and
    define a test case method.</p>
    
    <div class="Source Java">
<pre>import org.jmock.*;

class PublisherTest extends MockObjectTestCase {
    public void testOneSubscriberReceivesAMessage() {
    }
}</pre>
    </div>
    
    <p>We will now write the body of the 
    <code>testOneSubscriberReceivesAMessage</code> method.</p>
    
    <p>We first <i>set up</i> the context in which our test will execute.  
    We create a Publisher to test.  We create a mock Subscriber that should 
    receive the message.  We then register the Subscriber with the Publisher.  
    Finally we create a message object to publish.</p>
     
    <div class="Source Java">
<pre>Mock mockSubscriber = new Mock(Subscriber.class);
Publisher publisher = new Publisher();
publisher.add( (Subscriber)mockSubscriber.proxy() );

final Object message = new Object();</pre>
    </div>
  
    <p>Next we define <i>expectations</i> on the mock Subscriber that 
    specify the methods that we expect to be called upon it during the 
    test run.  We expect the receive method to be called with a single 
    argument, the message that will be sent.  The <code>same</code>
    method is defined in the MockObjectTestCase class and specifies
    that we expect the argument to be the same object as 
    <var>message</var>.
    We don't need to specify what will be returned from the receive method
    because it has a void return type.</p>
   
    <div class="Source Java">
		<pre>mockSubscriber.expect(once()).method("receive").with( same(message) );</pre>
    </div>
  
    <p>We then <i>execute</i> the code that we want to test.</p>
   
    <div class="Source Java">
      <pre>publisher.publish(message);</pre>
    </div>
  
    <p>Finally we <i>verify</i> that the mock Subscriber was called as 
    expected.  If we do not verify, our test will detect incorrect calls 
    to the mock Subscriber but not the complete lack of calls.</p>
   
    <div class="Source Java">
      <pre>mockSubscriber.verify();</pre>
    </div>
  
    <p>Here is the complete test.</p>
    
    <div class="Source Java">
<pre>import org.jmock.*;

class PublisherTest extends MockObjectTestCase {
    public void testOneSubscriberReceivesAMessage() {
        // set up
        Mock mockSubscriber = new Mock(Subscriber.class);
        Publisher publisher = new Publisher();
        publisher.add((Subscriber) mockSubscriber.proxy());
        
        final Object message = new Object();
        
        // expectations
        mockSubscriber.expect(once()).method("receive").with( same(message) );
        
        // execute
        publisher.publish(message);
        
        // verify
        mockSubscriber.verify();
    }
}</pre>
    </div>
    
    <p>That concludes this quick introduction.  More advanced topics are
    covered in <a href="docs.html#tutorials">other tutorials</a>.</p>
  </body>
</html>
  